<html>
	<head>
    <link rel="stylesheet" type="text/css" href="semantic/semantic.min.css">
    <script
        src="https://code.jquery.com/jquery-3.1.1.min.js"
        integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
        crossorigin="anonymous"></script>
    <script src="semantic/semantic.min.js"></script>
    <title>Assignment 3-1 Write-up (xyuan195)</title>
	</head>
	<body>
  <div class="ui container">
    <div class="ui center aligned container">
      <br>
      <h1>Assignment 3-1 (Pathtracer 1) Write-up</h1>
      <h4>Author: Xiaoyuan Zhu (m195@berkeley.edu)</h4>
    </div>

    <h2>Overview</h2>
    <p>
      In this assignment, I practiced on how to perform ray tracing, global illumination, and adaptive sampling.
    </p>
    <p>
      Online version of this write-up is hosted at:
      <a href="https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj3-1/index.html">
        https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj3-1/index.html
      </a>
    </p>

    <h2>Tasks Breakdown</h2>

    <h3>Part 1: Ray Generation and Scene Intersection</h3>
    <h4>[Part 1] Walk Through on Implementation Details</h4>
    <p>

    </p>

    <h4>[Part 1] Explanation of the Triangle Intersection Algorithm</h4>
    <p>

    </p>

    <h4>[Part 1] Some Images with Normal Shading</h4>
    <p>

    </p>

    <h3>Part 2: Bounding Volume Hierarchy</h3>

    <h4>[Part 2] Walk Through on BVH Construction Algorithm</h4>
    <h4>[Part 2] Images with BVH Acceleration</h4>
    <h4>[Part 2] Rendering Time Comparison between with and without BVH Acceleration</h4>

    <h3>Part 3: Direct Illumination</h3>

    <h4>[Part 3] Walk Through on Implementations of the Direct Lighting Function</h4>
    <h4>[Part 3] Images with Both Implementations of the Direct Lighting Function</h4>
    <h4>[Part 3] Noise Comparison between Both Implementations of the Direct Lighting Function</h4>
    <h4>[Part 3] Comparison between Both Implementations of the Direct Lighting Function</h4>

    <h3>Part 4: Global Illumination</h3>

    <h4>[Part 4] Walk Through on Implementation of the Indirect Lighting Function</h4>
    <p>
      To support indirect lighting function, I first implemented <b>DiffuseBSDF::sample_f</b> function to take a sample
      by a given outgoing light direction, and store the sampled incoming light direction to variable <b>wi</b> and its
      pdf to variable <b>pdf</b>. To do this, I first call <b>sampler.get_sample()</b> to get a sample, and then plug it
      in function <b>f</b> in Part 3 (along with the outgoing light direction <b>wo</b>) to get the bsdf, which is the
      return value. But before I return this value directly, I copy the sampled Vector3D to the input <b>wi</b> parameter,
      and copy the hardcoded <b>1 / PI</b> to the input <b>pdf</b> parameter, so that they will be propagated to the caller. At last,
      I return the calculated <b>bsdf</b> value.
    </p>
    <p>
      Having <b>sample_f</b> function ready, I can start the implementation of <b>PathTracer::at_least_one_bounce_radiance</b>
      function. First of all, I check the depth of the incoming ray object: if it is equal to 0, that means we've reached
      the max ray depth, I just return <b>L_out</b> directly. This is the base case of this recursion function. If the
      ray depth is bigger than 0, we can continue the process. Firstly, I add <b>one_bounce_radiance(r, isect)</b> to
      <b>L_out</b>.
    </p>
    <p>
      Then, I take a sample using the outgoing light direction <b>w_out</b> by calling <b>sample_f</b> function we created.
      This will give us a incoming light direction <b>wi</b> and its pdf <b>pdf</b>. We will use this sampled incoming light
      direction to construct the shadow ray (the ray from the current hit point to the sampled direction). To do this,
      first I need to convert <b>wi</b> in the object coordinates to <b>wi_w</b> in the world coordinates by calling
      <b>auto wi_w = o2w * wi</b>; then I need to normalize this <b>wi_w</b> Vector3D by calling <b>wi_w.normalize()</b>;
      lastly, the new shadow ray will be <b>{ hit_p, wi_w }</b> (origin as hit_p, and direction as wi_w). I also need to
      set the <b>min_t</b> of this new ray to <b>EPS_F</b>.
    </p>
    <p>
      With this new shadow ray in hand, I check whether there's any intersection with it in the scene by calling
      <b>bvh->intersect(next_r, &intersection)</b>. If the result is false, that means there's no intersection with this
      new shadow ray, I just return <b>L_out</b> directly. Otherwise, I continue the process with the new intersection
      value stored in <b>intersection</b> variable.
    </p>
    <p>
      Now, I need to use Russian Roulette algorithm to continue the recursion. Firstly, I created a new function
      <b>PathTracer::get_continuation_probability</b>, which will be used to calculate the continuation probability (cpdf)
      of the algorithm. It takes sampled <b>brdf</b> Vector3D variable, calculates the <b>norm2</b> value, and then
      calculates the percentile by <b>(3 - norm) / 3</b>, then return <b>0.3 + percentage * (0.4 - 0.3)</b>. Basically,
      this function will return a value between 0.3 and 0.4 proportional to the normal of the sampled brdf.
    </p>
    <p>
      After I get the continuation probability (cpdf) from the above function, I plug it in <b>coin_flip</b> function
      to randomly decide whether to continue the recursion or not. If the result of <b>coin_flip</b> is false, I just
      skip the recursion call and return <b>L_out</b> directly. Otherwise, I continue the process.
    </p>
    <p>
      As to continue the recursion, I firstly calculate the cosine theta by calculating the dot product of the intersection
      normal and the incoming light direction in world coordinates <b>dot(isect.n, wi_w)</b>, then I update the depth
      of the new shadow ray to <b>r.depth - 1</b> for next recursion call, so that we can terminate the calculation by
      <b>max_ray_depth</b>. Then I recursively call <b>at_least_one_bounce_radiance</b> with the new shadow ray and the
      new intersection, and plug in its result in formula <b>at_least_one_bounce_radiance(next_r, intersection) * brdf * cos / pdf / cpdf</b>.
      Then I add the final result to <b>L_out</b>. This concludes the implementation of
      <b>at_least_one_bounce_radiance</b> function.
    </p>
    <p>
      Then I modify <b>est_radiance_global_illumination</b> function to use <b>at_least_one_bounce_radiance</b> function.
      The final <b>L_out</b> is calculated as <b>zero_bounce_radiance(r, isect) + at_least_one_bounce_radiance(r, isect)</b>.
    </p>
    <p>
      Finally, I need to modify <b>raytrace_pixel</b> function. For each sample ray, I set its depth to <b>max_ray_depth</b>,
      such that we can terminate the recursion call of <b>at_least_one_bounce_radiance</b> function if the max ray depth
      is reached.
    </p>

    <h4>[Part 4] Images Rendered with Global Illumination</h4>
    <h4>[Part 4] Comparison between Direct and Indirect Illumination</h4>
    <h4>[Part 4] max_ray_depth Comparisons</h4>
    <div class="ui info message">
      All below images are generated with Russian Roulette enabled and sample rate per pixel as 1024.
    </div>
    <div class="ui two column grid">
      <div class="row">
        <div class="column ui segment">
          <img src="./assets/part-4_bunny_m0.png">
          <h5 class="ui center aligned container">Max Ray Depth 0 for CBbunny.dae</h5>
        </div>
        <div class="column ui segment">
          <img src="./assets/part-4_bunny_m1.png">
          <h5 class="ui center aligned container">Max Ray Depth 1 for CBbunny.dae</h5>
        </div>
      </div>
      <div class="row">
        <div class="column ui segment">
          <img src="./assets/part-4_bunny_m2.png">
          <h5 class="ui center aligned container">Max Ray Depth 2 for CBbunny.dae</h5>
        </div>
        <div class="column ui segment">
          <img src="./assets/part-4_bunny_m3.png">
          <h5 class="ui center aligned container">Max Ray Depth 3 for CBbunny.dae</h5>
        </div>
      </div>
      <div class="row">
        <div class="column ui segment">
          <img src="./assets/part-4_bunny_m100.png">
          <h5 class="ui center aligned container">Max Ray Depth 100 for CBbunny.dae</h5>
        </div>
      </div>
    </div>
    <h4>[Part 4] sample-per-pixel Comparisons</h4>
    <div class="ui info message">
      All below images are generated with Russian Roulette enabled.
    </div>
    <div class="ui two column grid">
      <div class="row">
        <div class="column ui segment">
          <img src="./assets/part-4_spheres_1.png">
          <h5 class="ui center aligned container">1 Ray Sample Per Pixel</h5>
        </div>
        <div class="column ui segment">
          <img src="./assets/part-4_spheres_2.png">
          <h5 class="ui center aligned container">2 Ray Samples Per Pixel</h5>
        </div>
      </div>
      <div class="row">
        <div class="column ui segment">
          <img src="./assets/part-4_spheres_4.png">
          <h5 class="ui center aligned container">4 Ray Samples Per Pixel</h5>
        </div>
        <div class="column ui segment">
          <img src="./assets/part-4_spheres_8.png">
          <h5 class="ui center aligned container">8 Ray Samples Per Pixel</h5>
        </div>
      </div>
      <div class="row">
        <div class="column ui segment">
          <img src="./assets/part-4_spheres_64.png">
          <h5 class="ui center aligned container">64 Ray Samples Per Pixel</h5>
        </div>
        <div class="column ui segment">
          <img src="./assets/part-4_spheres_1024.png">
          <h5 class="ui center aligned container">1024 Ray Samples Per Pixel</h5>
        </div>
      </div>
    </div>

    <h3>Part 5: Adaptive Sampling</h3>
    <h4>[Part 5] Explanation and Walk Through on Adaptive Sampling</h4>
    <h4>[Part 5] Images</h4>
    <br><br>
    <div class="ui right aligned container">
      <h5>
        Live version of this write-up is hosted at
        <a href="https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj3-1/index.html">
          https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj3-1/index.html
        </a>
      </h5>
      <br><br>
    </div>
  </div>
	</body>
</html>