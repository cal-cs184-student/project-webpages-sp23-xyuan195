<html>
<head>
	<link rel="stylesheet" type="text/css" href="semantic/semantic.min.css">
	<script
			src="https://code.jquery.com/jquery-3.1.1.min.js"
			integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
			crossorigin="anonymous"></script>
	<script src="semantic/semantic.min.js"></script>
	<title>Assignment 2 Write-up (xyuan195)</title>
</head>
<body>
	<div class="ui container">
		<div class="ui center aligned container">
			<br>
			<h1>Assignment 2 (MeshEdit) Write-up</h1>
			<h4>Author: Xiaoyuan Zhu (m195@berkeley.edu)</h4>
			<h4><a href="https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj2/index.html">Project Github Repo</a></h4>
		</div>

		<h2>Overview</h2>
		<p>
			In this assignment, I practiced on how to construct Bezier curves and surfaces using de Casteljau subdivision. I
			also explored different mesh operations and how to do mesh upsampling with Loop subdivision.
		</p>

		<h2>Tasks Breakdown</h2>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision (
			<a href="https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj2/index.html">
				https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj2/index.html
			</a>
			)
		</h3>
		<h4>[Part 1] Walk Through on Implementation Details</h4>
		<p>
			De Casteljau algorithm is a recursive way to evaluate Bezier curves using linear interpolation.
		</p>
		<p>
			To calculate each point at the next level, I perform linear interpolation for the current point (with the same
			index) and the next point (with index + 1) at the current level, except for the last point, which I just copy it
			to the next level. To be precise, the linear interpolation is calculated as
			<b>(1 - t) * points.at(i) + t * points.at(i + 1)</b>, where t is the value between 0 and 1 to evaluate the Bezier
			curve at.
		</p>

		<h4>[Part 1] Screenshots of my own ".bzc" file</h4>
		<div class="ui two column grid">
			<div class="row">
				<div class="column ui segment">
					<img src="./assets/task-1_level0.png">
					<h5 class="ui center aligned container">Level 0</h5>
				</div>
				<div class="column ui segment">
					<img src="./assets/task-1_level1.png">
					<h5 class="ui center aligned container">Level 1</h5>
				</div>
			</div>
			<div class="row">
				<div class="column ui segment">
					<img src="./assets/task-1_level2.png">
					<h5 class="ui center aligned container">Level 2</h5>
				</div>
				<div class="column ui segment">
					<img src="./assets/task-1_level3.png">
					<h5 class="ui center aligned container">Level 3</h5>
				</div>
			</div>
			<div class="row">
				<div class="column ui segment">
					<img src="./assets/task-1_level4.png">
					<h5 class="ui center aligned container">Level 4</h5>
				</div>
				<div class="column ui segment">
					<img src="./assets/task-1_level5.png">
					<h5 class="ui center aligned container">Level 5</h5>
				</div>
			</div>
			<div class="row">
				<div class="column ui segment">
					<img src="./assets/task-1_curve.png">
					<h5 class="ui center aligned container">Final Bezier Curve</h5>
				</div>
				<div class="column ui segment">
					<img src="./assets/task-1_curve_only.png">
					<h5 class="ui center aligned container">Bezier Curve Only</h5>
				</div>
			</div>
		</div>

		<h4>[Part 1] Screenshots of changing control points and/or parameter t</h4>
		<div class="ui two column grid">
			<div class="row">
				<div class="column ui segment">
					<img src="./assets/task-1_change_control_points.png">
					<h5 class="ui center aligned container">Change Control Points</h5>
				</div>
				<div class="column ui segment">
					<img src="./assets/task-1_change_t.png">
					<h5 class="ui center aligned container">Change Parameter t</h5>
				</div>
			</div>
		</div>

		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau (
			<a href="https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj2/index.html">
				https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj2/index.html
			</a>
			)
		</h3>

		<h4>[Part 2] Walk Through on Implementation Details</h4>
		<p>
			Using de Casteljau subdivision to evaluate Bezier surfaces in 3D is an extension of using it to evaluate Bezier
			curves in 2D. Here are the detailed steps:
		</p>
		<p>
      First, create <b>BezierPatch::evaluateStep</b> function to perform one step of de Casteljau's algorithm. This is
      very similar to the implementation of Part 1, except this is for <b>Vector3D</b>: use linear interpolation to
      evaluate each point in next step using the point with the same index and the point with index + 1 in the current
      step, and copy the last point over to the next step.
    </p>
    <p>
      Secondly, create <b>BezierPatch::evaluate1D</b> function to fully evaluate de Casteljau's algorithm for a vector
      of points at parameter t. This function will recursively call <b>BezierPatch::evaluateStep</b> with the result
      from the last iteration. The total number of iterations is number of control points minus one (<b>points.size() - 1</b>).
      Then the first point of the final evaluated list of control points is the point on the Bezier curve.
    </p>
    <p>
      Finally, create <b>Vector3D BezierPatch::evaluate</b> function to take parameter <b>(u, v)</b> to fully evaluate
      the Bezier surface. The steps are: for each row of control points, we call <b>BezierPatch::evaluate1D</b> with
      parameter <b>u</b> to get a vector of intermediate points; then call <b>BezierPatch::evaluate1D</b> with this vector
      of intermediate points and parameter <b>v</b> to get the point on the Bezier surface.
    </p>

		<h4>[Part 2] Screenshot of "bez/teapot.bez"</h4>
		<div class="ui segment">
			<img src="./assets/task-2.png">
			<h5 class="ui center aligned container">Screenshot of "bez/teapot.bez"</h5>
		</div>

		<h3>Part 3: Area-weighted vertex normals (
			<a href="https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj2/index.html">
				https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj2/index.html
			</a>
			)
		</h3>

    <h4>[Part 3] Walk Through on Implementation Details</h4>
    <p>
      The high-level idea of implementing area-weighted vertex model is to use the <b>Halfedge</b> data structure to
      iterate through the adjacent vertexes (and their corresponding faces), and get the normal vector and the area of
      each face, and calculate the weighted average. Please see detailed steps as follows:
    </p>
    <p>
      1) Initialize <b>Vector3D sum</b> and <b>double total_area</b> variables to accumulate calculated result in each iteration.
    </p>
    <p>
      2) Construct the loop structure using <b>Halfedge</b> data structure (this is very similar to
      <b>printNeighborPositions</b> function in the Halfedge primer): first, get the halfedge (actually it's <b>HalfedgeCIter</b>)
      of the target vertex and put it in a pointer <b>h</b>, which will be used for iteration, before the loop; then start a
      <b>do.. while</b> loop.
    </p>
    <p>
      3) Inside the loop, get the twin of the halfedge, and all vertexes' positions (say <b>v0, v1, v2</b>) of the face
      formed by the twin halfedge.
    </p>
    <p>
      4) Calculate the 2 edge vectors started at vertex v0 (<b>v1 - v0</b> and <b>v2 - v0</b>)
    </p>
    <p>
      5) Calculate the cross product of the 2 edge vectors by calling <b>Vector3D::cross</b>.
    </p>
    <p>
      6) Get the unit vector of the cross product by calling <b>Vector3D::unit</b>, which is the normal of the face.
    </p>
    <p>
      7) Get the area of the face by <b>cross_product.norm() / 2</b>.
    </p>
    <p>
      8) Accumulate <b>Vector3D sum</b> and <b>double total_area</b> variables by <b>sum += area * face_norm;</b> and
      <b>total_area += area;</b>
    </p>
    <p>
      9) Assign <b>h_twin->next()</b> to pointer <b>h</b>, which was set up before the loop in step 2).
    </p>
    <p>
      10) Terminate the loop if <b>h</b> is the same as the halfedge of the target vertex.
    </p>
    <p>
      11) Finally, calculate the weighted average by <b>sum / total_area</b>.
    </p>

    <h4>[Part 3] Screenshots of "dae/teapot.dae"</h4>
    <div class="ui two column grid">
      <div class="row">
        <div class="column ui segment">
          <img src="./assets/task-3_default.png">
          <h5 class="ui center aligned container">Default Flat Shading</h5>
        </div>
        <div class="column ui segment">
          <img src="./assets/task-3_phong.png">
          <h5 class="ui center aligned container">Phong Shading</h5>
        </div>
      </div>
    </div>

		<h3>Part 4: Edge flip (
			<a href="https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj2/index.html">
				https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj2/index.html
			</a>
			)
		</h3>

    <h4>[Part 4] Walk Through on Implementation Details</h4>
    <p>
      My approach of solving this problem is to draw out what will change after the edge flip, in terms of edges, faces,
      vertexes, and halfedges. I found what works best for me is to draw out a simple mesh before and after the edge flip.
      Please see below:
    </p>
    <div class="ui two column grid">
      <div class="row">
        <div class="column ui segment">
          <img src="./assets/task-4_draw_before.png">
          <h5 class="ui center aligned container">A simple mesh before the edge flips</h5>
        </div>
        <div class="column ui segment">
          <img src="./assets/task-4_draw_after.png">
          <h5 class="ui center aligned container">A simple mesh after the edge flips</h5>
        </div>
      </div>
    </div>

    <p>
      From the above drawings, I can see I have:
    </p>
    <ul class="ui">
      <li>4 vertexes:</li>
      <ul>
        <li>Vertex A (v_a in code)</li>
        <li>Vertex B (v_b in code)</li>
        <li>Vertex C (v_c in code)</li>
        <li>Vertex D (v_d in code)</li>
      </ul>
      <li>2 faces:</li>
      <ul>
        <li>f0</li>
        <li>f1</li>
      </ul>
      <li>6 halfedges:</li>
      <ul>
        <li>he0 (the halfedge of the input edge)</li>
        <li>he1 (the twin of he0)</li>
        <li>he2</li>
        <li>he3</li>
        <li>he4</li>
        <li>he5</li>
      </ul>
    </ul>

    <p>
      After the flip, I still have the same amount of elements, but their neighbors are changed. So essentially, my code
      can be divided into 3 steps:
    </p>
    <p>
      <b>Step 1:</b> Get all elements in the drawing, and assign them to local variables.
    </p>
    <p>
      <b>Step 2:</b> Use <b>Halfedge::setNeighbors</b> to update neighbors to match the graph after the edge flip. I ended up
      with the following table to help me visualize the process.
    </p>
    <table class="ui celled table">
      <thead>
        <tr>
          <th>Halfedge</th>
          <th>Next</th>
          <th>Twin</th>
          <th>Vertex</th>
          <th>Edge</th>
          <th>Face</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>he0</td>
          <td>he5</td>
          <td>he1</td>
          <td>v_c</td>
          <td>e0</td>
          <td>f0</td>
        </tr>
        <tr>
          <td>he1</td>
          <td>he3</td>
          <td>he0</td>
          <td>v_d</td>
          <td>e0</td>
          <td>f1</td>
        </tr>
        <tr>
          <td>he2</td>
          <td>he0</td>
          <td>he2->twin()</td>
          <td>v_b</td>
          <td>he2->edge()</td>
          <td>f0</td>
        </tr>
        <tr>
          <td>he3</td>
          <td>he4</td>
          <td>he3->twin()</td>
          <td>v_c</td>
          <td>he3->edge()</td>
          <td>f1</td>
        </tr>
        <tr>
          <td>he4</td>
          <td>he1</td>
          <td>he4->twin()</td>
          <td>v_a</td>
          <td>he4->edge()</td>
          <td>f1</td>
        </tr>
        <tr>
          <td>he5</td>
          <td>he2</td>
          <td>he5->twin()</td>
          <td>v_d</td>
          <td>he5->edge()</td>
          <td>f0</td>
        </tr>
      </tbody>
    </table>
    <p>
      <b>Step 3:</b> Reset halfedge pointers for all faces, edges, and vertexes involved
      (<b>f0, f1, v_a, v_b, v_c, v_d, e0</b>).
    </p>

    <p>
      The process/logic looks very simple, but I did spend a big chunk of time on debugging this problem. I initially
      wanted to take a shortcut to set the new neighbors directly without listing them out on a scratch paper. But it
      turned out I missed out several halfedges in step 2 and several vertexes in step 3. As I mentioned above, the
      drawings and the transition table really helped me get this right.
    </p>

    <h4>[Part 4] Screenshots of before/after edge flips</h4>
    <div class="ui two column grid">
      <div class="row">
        <div class="column ui segment">
          <img src="./assets/task-4_before.png">
          <h5 class="ui center aligned container">Before the edge flips</h5>
        </div>
        <div class="column ui segment">
          <img src="./assets/task-4_after.png">
          <h5 class="ui center aligned container">After the edge flips (in the bottom right corner)</h5>
        </div>
      </div>
    </div>

		<h3>Part 5: Edge split (
			<a href="https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj2/index.html">
				https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj2/index.html
			</a>
			)
		</h3>

		<h3>Part 6: Loop subdivision for mesh upsampling (
			<a href="https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj2/index.html">
				https://cal-cs184-student.github.io/project-webpages-sp23-xyuan195/proj2/index.html
			</a>
			)
		</h3>
	</div>
</body>
</html>